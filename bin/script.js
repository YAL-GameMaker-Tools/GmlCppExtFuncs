// Generated by Haxe 4.2.0
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var CharCode = {};
CharCode.isSpace = function(this1) {
	var c = this1;
	if(!(c == 32 || c == 9 || c == 13)) {
		return c == 10;
	} else {
		return true;
	}
};
CharCode.isIdent0 = function(this1) {
	var c = this1;
	if(!(c == 95 || c >= 97 && c <= 122)) {
		if(c >= 65) {
			return c <= 90;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
CharCode.isIdent1 = function(this1) {
	var c = this1;
	if(!(c == 95 || c >= 97 && c <= 122 || c >= 65 && c <= 90)) {
		if(c >= 48) {
			return c <= 57;
		} else {
			return false;
		}
	} else {
		return true;
	}
};
CharCode.isDigit = function(this1) {
	var c = this1;
	if(c >= 48) {
		return c <= 57;
	} else {
		return false;
	}
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var CppBufFormatMeta = function(fn,simple) {
	this.func = fn;
	this.simple = simple;
};
CppBufFormatMeta.__name__ = true;
var CppBuf = function() {
	this.indent = 0;
	StringBuf.call(this);
};
CppBuf.__name__ = true;
CppBuf.addFormat_pre = function(fmt) {
	var parts = CppBuf.addFormat_cache.h[fmt];
	if(parts != null) {
		return parts;
	}
	parts = [];
	var start = 0;
	var q = new CppReader(fmt);
	while(q.pos < q.len) {
		if(q.read() != 37) {
			continue;
		}
		var at = q.pos - 1;
		if(at > start) {
			parts.push(CppBufFormatPart.FString(fmt.substring(start,at)));
		}
		var tag;
		if(CharCode.isIdent0(q.peek())) {
			tag = q.readIdent(true);
		} else {
			tag = q.substr(at,2);
			q.pos += 1;
		}
		var meta = CppBuf.addFormat_map.h[tag];
		if(meta == null) {
			throw haxe_Exception.thrown("Unknown format " + tag + " in " + fmt);
		}
		parts.push(meta.simple ? CppBufFormatPart.FSimple(meta.func) : CppBufFormatPart.FNext(meta.func));
		start = q.pos;
	}
	var till = q.pos;
	if(till > start) {
		parts.push(CppBufFormatPart.FString(fmt.substring(start,till)));
	}
	CppBuf.addFormat_cache.h[fmt] = parts;
	return parts;
};
CppBuf.fmt = function(fmt) {
	var $l=arguments.length;
	var rest = new Array($l>1?$l-1:0);
	for(var $i=1;$i<$l;++$i){rest[$i-1]=arguments[$i];}
	var parts = CppBuf.addFormat_pre(fmt);
	var argi = 0;
	var argc = rest.length;
	var b = new CppBuf();
	var _g = 0;
	while(_g < parts.length) {
		var part = parts[_g];
		++_g;
		switch(part._hx_index) {
		case 0:
			var s = part.s;
			b.b += s == null ? "null" : "" + s;
			break;
		case 1:
			var f = part.fn;
			f(b,null,-1);
			break;
		case 2:
			var f1 = part.fn;
			if(argi >= argc) {
				throw haxe_Exception.thrown("Not enough rest-arguments for %arg");
			}
			f1(b,rest[argi],argi);
			++argi;
			break;
		}
	}
	if(argi < argc) {
		throw haxe_Exception.thrown("Too many %args");
	}
	return b.b;
};
CppBuf.__super__ = StringBuf;
CppBuf.prototype = $extend(StringBuf.prototype,{
	addLine: function(d) {
		if(d == null) {
			d = 0;
		}
		this.indent += d;
		this.b += String.fromCodePoint(10);
		var _g = 0;
		var _g1 = this.indent;
		while(_g < _g1) {
			var _ = _g++;
			this.b += String.fromCodePoint(9);
		}
	}
	,addString: function(s) {
		this.b += s == null ? "null" : "" + s;
	}
	,addInt: function(i) {
		this.b += i == null ? "null" : "" + i;
	}
	,addBuffer: function(b) {
		this.b += Std.string(b.b);
	}
	,addFormat: function(fmt) {
		var $l=arguments.length;
		var rest = new Array($l>1?$l-1:0);
		for(var $i=1;$i<$l;++$i){rest[$i-1]=arguments[$i];}
		var parts = CppBuf.addFormat_pre(fmt);
		var argi = 0;
		var argc = rest.length;
		var _g = 0;
		while(_g < parts.length) {
			var part = parts[_g];
			++_g;
			switch(part._hx_index) {
			case 0:
				var s = part.s;
				this.b += s == null ? "null" : "" + s;
				break;
			case 1:
				var f = part.fn;
				f(this,null,-1);
				break;
			case 2:
				var f1 = part.fn;
				if(argi >= argc) {
					throw haxe_Exception.thrown("Not enough rest-arguments for %arg");
				}
				f1(this,rest[argi],argi);
				++argi;
				break;
			}
		}
		if(argi < argc) {
			throw haxe_Exception.thrown("Too many %args");
		}
	}
});
var CppBufFormatPart = $hxEnums["CppBufFormatPart"] = { __ename__:true,__constructs__:null
	,FString: ($_=function(s) { return {_hx_index:0,s:s,__enum__:"CppBufFormatPart",toString:$estr}; },$_._hx_name="FString",$_.__params__ = ["s"],$_)
	,FSimple: ($_=function(fn) { return {_hx_index:1,fn:fn,__enum__:"CppBufFormatPart",toString:$estr}; },$_._hx_name="FSimple",$_.__params__ = ["fn"],$_)
	,FNext: ($_=function(fn) { return {_hx_index:2,fn:fn,__enum__:"CppBufFormatPart",toString:$estr}; },$_._hx_name="FNext",$_.__params__ = ["fn"],$_)
};
CppBufFormatPart.__constructs__ = [CppBufFormatPart.FString,CppBufFormatPart.FSimple,CppBufFormatPart.FNext];
var CppFunc = function(name) {
	this.args = [];
	this.name = name;
};
CppFunc.__name__ = true;
CppFunc.read = function(q) {
	var retType = CppType.read(q);
	var fnName = q.readSpIdent();
	q.skipSpaces();
	if(!q.skipIfEqu(40)) {
		return;
	}
	var fn = new CppFunc(fnName);
	fn.retType = retType;
	CppFunc.list.push(fn);
	var readArg = true;
	var depth = 1;
	_hx_loop1: while(q.pos < q.len) {
		var c = q.read();
		switch(c) {
		case 40:
			++depth;
			break;
		case 41:
			if(--depth <= 0) {
				break _hx_loop1;
			}
			break;
		case 44:
			if(depth == 1) {
				readArg = true;
			} else if(CharCode.isIdent0(c)) {
				var w = q.readIdent(true);
				if(readArg) {
					readArg = false;
					var argType = CppType.read(q,w);
					var argName = q.readSpIdent();
					if(argName == "") {
						continue;
					}
					var arg = new CppFuncArg(argType,argName);
					fn.args.push(arg);
					q.skipSpaces();
					if(q.skipIfEqu(61)) {
						q.skipSpaces();
						var valStart = q.pos;
						_hx_loop2: while(q.pos < q.len) {
							c = q.read();
							switch(c) {
							case 40:
								++depth;
								break;
							case 41:
								if(--depth <= 1) {
									break _hx_loop2;
								}
								break;
							case 44:
								if(depth <= 1) {
									break _hx_loop2;
								}
								break;
							}
						}
						arg.value = StringTools.trim(q.substring(valStart,q.pos - 1));
						if(depth <= 0) {
							break _hx_loop1;
						}
					}
				}
			}
			break;
		default:
			if(CharCode.isIdent0(c)) {
				var w1 = q.readIdent(true);
				if(readArg) {
					readArg = false;
					var argType1 = CppType.read(q,w1);
					var argName1 = q.readSpIdent();
					if(argName1 == "") {
						continue;
					}
					var arg1 = new CppFuncArg(argType1,argName1);
					fn.args.push(arg1);
					q.skipSpaces();
					if(q.skipIfEqu(61)) {
						q.skipSpaces();
						var valStart1 = q.pos;
						_hx_loop3: while(q.pos < q.len) {
							c = q.read();
							switch(c) {
							case 40:
								++depth;
								break;
							case 41:
								if(--depth <= 1) {
									break _hx_loop3;
								}
								break;
							case 44:
								if(depth <= 1) {
									break _hx_loop3;
								}
								break;
							}
						}
						arg1.value = StringTools.trim(q.substring(valStart1,q.pos - 1));
						if(depth <= 0) {
							break _hx_loop1;
						}
					}
				}
			}
		}
	}
};
CppFunc.prototype = {
	print: function(gml,cpp) {
		gml.addFormat("#define %s",this.name);
		var argGcTypes = [];
		var hasOptArgs = false;
		var _g = 0;
		var _g1 = this.args;
		while(_g < _g1.length) {
			var arg = _g1[_g];
			++_g;
			if(arg.value != null) {
				hasOptArgs = true;
			}
			argGcTypes.push(arg.type.toGmlCppType());
		}
		var retCppType = this.retType.toCppType();
		var hasReturn = retCppType != "void";
		var retGcType = this.retType.toGmlCppType();
		gml.addFormat("%|/// %s(",this.name);
		var _g2_current = 0;
		var _g2_array = this.args;
		while(_g2_current < _g2_array.length) {
			var _g3_value = _g2_array[_g2_current];
			var _g3_key = _g2_current++;
			var i = _g3_key;
			var arg = _g3_value;
			if(i > 0) {
				gml.b += ", ";
			}
			gml.addFormat("%s",arg.name);
			if(arg.value != null) {
				gml.addFormat(" = %s",arg.value);
			}
		}
		gml.b += ")";
		if(hasReturn) {
			gml.b += "->";
		}
		gml.addLine();
		cpp.addFormat("extern %s %s(",retCppType,this.name);
		var argSize = 0;
		var _g2_current = 0;
		var _g2_array = this.args;
		while(_g2_current < _g2_array.length) {
			var _g3_value = _g2_array[_g2_current];
			var _g3_key = _g2_current++;
			var i = _g3_key;
			var arg = _g3_value;
			if(i > 0) {
				cpp.b += ", ";
			}
			cpp.addFormat("%s %s",arg.type.toCppType(),arg.name);
			argSize += arg.type.get_proc().getSize();
		}
		cpp.addFormat(");%|");
		var cppName = StringTools.replace(CppGen.nameFormat,"$",this.name);
		cpp.addFormat("%s ",CppGen.exportPrefix);
		cpp.addFormat("%s ",retGcType != null ? retGcType : "double");
		cpp.addFormat("%s(void* __ptr__",cppName);
		var cppArgs = new CppBuf();
		cppArgs.indent = cpp.indent + 1;
		cppArgs.addFormat("gml_buffer __buf__(__ptr__);");
		var gmlCall = new CppBuf();
		gmlCall.addFormat("%s(buffer_get_address(__buf__)",cppName);
		gml.addFormat("var __buf__ = %s(%d);",CppGen.prepareBuffer,argSize);
		var hasBufArgs = false;
		var _g2_current = 0;
		var _g2_array = this.args;
		while(_g2_current < _g2_array.length) {
			var _g3_value = _g2_array[_g2_current];
			var _g3_key = _g2_current++;
			var i = _g3_key;
			var arg = _g3_value;
			var argGcType = argGcTypes[i];
			var argGmlRef = hasOptArgs ? "argument[" + i + "]" : "argument" + i;
			if(argGcType == null) {
				hasBufArgs = true;
				var td = CppTypeHelper.find(arg.type);
				cppArgs.addFormat("%|%s %s;%|",arg.type.toCppType(),arg.name);
				if(arg.value != null) {
					gml.addFormat("%|if (argument_count >= %d) {%+",i);
					gml.addFormat("buffer_write(__buf__, buffer_bool, true);");
					cppArgs.addFormat("if (__buf__.read<bool>()) {%+");
				}
				td.gmlWrite(gml,0,argGmlRef);
				cppArgs.addFormat("%s = %s;",arg.name,td.cppRead(cppArgs,arg.type));
				if(arg.value != null) {
					gml.addFormat("%-} else buffer_write(__buf__, buffer_bool, false);");
					cppArgs.addFormat("%-} else %s = %s;",arg.name,arg.value);
				}
			} else if(argGcType == "double") {
				hasBufArgs = true;
				var td1 = CppTypeHelper.find(arg.type);
				cppArgs.addFormat("%|%s %s;%|",arg.type.toCppType(),arg.name);
				if(arg.value != null) {
					gml.addFormat("%|if (argument_count >= %d) {%+",i);
					gml.addFormat("buffer_write(__buf__, buffer_bool, true);");
					cppArgs.addFormat("if (__buf__.read<bool>()) {%+");
				}
				td1.gmlWrite(gml,0,argGmlRef);
				cppArgs.addFormat("%s = %s;",arg.name,td1.cppRead(cppArgs,arg.type));
				if(arg.value != null) {
					gml.addFormat("%-} else buffer_write(__buf__, buffer_bool, false);");
					cppArgs.addFormat("%-} else %s = %s;",arg.name,arg.value);
				}
			} else {
				cpp.addFormat(", %s %s",argGcType,arg.name);
				gmlCall.addFormat(", %s",argGmlRef);
			}
		}
		gmlCall.addFormat(")");
		cpp.addFormat(") {%+");
		cpp.b += Std.string(cppArgs.b);
		var cppCall = new CppBuf();
		cppCall.addFormat("%s(",this.name);
		var _g2_current = 0;
		var _g2_array = this.args;
		while(_g2_current < _g2_array.length) {
			var _g3_value = _g2_array[_g2_current];
			var _g3_key = _g2_current++;
			var i = _g3_key;
			var arg = _g3_value;
			if(i > 0) {
				cppCall.addFormat(", ");
			}
			cppCall.addFormat("%s",arg.name);
		}
		cppCall.addFormat(")");
		cpp.addFormat("%|");
		var retTypeProc = hasReturn ? CppTypeHelper.find(this.retType) : null;
		if(!hasReturn) {
			cpp.addFormat("%b;",cppCall);
			cpp.addFormat("%|return 1;");
		} else if(retGcType != null) {
			cpp.addFormat("return %b;",cppCall);
		} else {
			cpp.addFormat("%s __ret__ = %b;",retCppType,cppCall);
			if(hasBufArgs) {
				cpp.addFormat("%|__buf__.rewind();");
			}
			retTypeProc.cppWrite(cpp,this.retType,"__ret__");
			cpp.addFormat("%|return 1;");
		}
		if(!hasReturn) {
			gml.addFormat("%|%b;",gmlCall);
		} else if(retGcType != null) {
			gml.addFormat("%|return %b;",gmlCall);
		} else {
			gml.addFormat("%|if (%b) {%+",gmlCall);
			if(hasBufArgs) {
				gml.addFormat("buffer_seek(__buf__, buffer_seek_start, 0);%|");
			}
			gml.addFormat("return %s;",retTypeProc.gmlRead(gml,0));
			gml.addFormat("%-} else return undefined;");
		}
		cpp.addFormat("%-}%|%|");
		gml.addFormat("%|%|");
	}
};
var CppFuncArg = function(type,name) {
	this.value = null;
	this.type = type;
	this.name = name;
};
CppFuncArg.__name__ = true;
var CppGen = function() { };
CppGen.__name__ = true;
CppGen.procFile = function(path,cpp) {
	var kwMacro = "dllw";
	var q = new CppReader(cpp);
	while(q.pos < q.len) {
		var c = q.read();
		switch(c) {
		case 34:case 39:
			q.skipCString(c);
			break;
		case 47:
			switch(q.peek()) {
			case 42:
				q.skipUntilStr("*/");
				break;
			case 47:
				q.skipUntil(10);
				break;
			}
			break;
		default:
			if(CharCode.isIdent0(c)) {
				var w = q.readIdent(true);
				if(w == "struct") {
					CppStruct.read(q);
				} else if(w == kwMacro) {
					CppFunc.read(q);
				}
			}
		}
	}
};
CppGen.finish = function() {
	var gml = new CppBuf();
	var cpp = new CppBuf();
	console.log("src/CppGen.hx:40:",CppFunc.list);
	var _g = 0;
	var _g1 = CppFunc.list;
	while(_g < _g1.length) {
		var fn = _g1[_g];
		++_g;
		fn.print(gml,cpp);
	}
	console.log("src/CppGen.hx:44:",gml.b);
	console.log("src/CppGen.hx:45:",cpp.b);
};
CppGen.test = function(cpp) {
	CppGen.procFile("test.cpp",cpp);
	CppGen.finish();
};
CppGen.main = function() {
	var h = new haxe_http_HttpJs("test.cpp?v=" + new Date().getTime());
	h.onData = function(s) {
		CppGen.test(s);
	};
	h.request();
};
var CppReader = function(s) {
	this.pos = 0;
	this.str = s;
	this.len = s.length;
};
CppReader.__name__ = true;
CppReader.prototype = {
	get_loop: function() {
		return this.pos < this.len;
	}
	,read: function() {
		return this.str.charCodeAt(this.pos++);
	}
	,peek: function() {
		return this.str.charCodeAt(this.pos);
	}
	,peekn: function(n) {
		return HxOverrides.substr(this.str,this.pos,n);
	}
	,substr: function(pos,len) {
		return HxOverrides.substr(this.str,pos,len);
	}
	,substring: function(start,end) {
		return this.str.substring(start,end);
	}
	,skip: function(n) {
		if(n == null) {
			n = 1;
		}
		this.pos += n;
	}
	,back: function(n) {
		if(n == null) {
			n = 1;
		}
		this.pos -= n;
	}
	,skipIfEqu: function(c) {
		if(this.peek() == c) {
			var n = 1;
			if(n == null) {
				n = 1;
			}
			this.pos += n;
			return true;
		} else {
			return false;
		}
	}
	,readIdent: function(pastFirst) {
		var start = pastFirst ? this.pos - 1 : this.pos;
		while(this.pos < this.len) {
			var c = this.peek();
			if(CharCode.isIdent1(c)) {
				this.pos++;
			} else {
				break;
			}
		}
		return this.substring(start,this.pos);
	}
	,readSpIdent: function() {
		while(this.pos < this.len) {
			var c = this.peek();
			if(CharCode.isSpace(c)) {
				this.pos += 1;
			} else {
				break;
			}
		}
		var start = null ? this.pos - 1 : this.pos;
		while(this.pos < this.len) {
			var c = this.peek();
			if(CharCode.isIdent1(c)) {
				this.pos++;
			} else {
				break;
			}
		}
		return this.substring(start,this.pos);
	}
	,skipUntil: function(c) {
		while(this.pos < this.len) if(this.read() == c) {
			break;
		}
	}
	,skipSpaces: function() {
		while(this.pos < this.len) {
			var c = this.peek();
			if(CharCode.isSpace(c)) {
				this.pos += 1;
			} else {
				break;
			}
		}
	}
	,skipUntilStr: function(s) {
		var n = s.length;
		while(this.pos < this.len) if(this.substr(this.pos,n) == s) {
			this.pos += n;
			break;
		} else {
			this.pos++;
		}
	}
	,skipCString: function(c1) {
		while(this.pos < this.len) {
			var c = this.read();
			if(c == c1) {
				break;
			}
			if(c == 92) {
				this.pos++;
			}
		}
	}
};
var CppStruct = function(name) {
	this.fields = [];
	this.name = name;
	this.proc = new proc_CppTypeProcStruct(this);
};
CppStruct.__name__ = true;
CppStruct.readStructField = function(q,struct,firstIdent) {
	var fdType = CppType.read(q,firstIdent);
	if(fdType == null) {
		return;
	}
	_hx_loop1: while(q.pos < q.len) {
		q.skipSpaces();
		var fdName = q.readIdent();
		if(fdName == "") {
			break;
		}
		q.skipSpaces();
		if(q.peek() == 40) {
			break;
		}
		var fd = new CppStructField(fdType,fdName);
		while(q.skipIfEqu(91)) {
			q.skipSpaces();
			var n = Std.parseInt(q.readIdent());
			q.skipSpaces();
			q.skipIfEqu(93);
			q.skipSpaces();
			if(n == null) {
				break;
			}
			fd.size.push(n);
		}
		struct.fields.push(fd);
		q.skipSpaces();
		if(q.skipIfEqu(61)) {
			q.skipSpaces();
			var depth = 0;
			_hx_loop3: while(q.pos < q.len) {
				var c = q.read();
				switch(c) {
				case 34:case 39:
					q.skipCString(c);
					break;
				case 44:
					if(depth == 0) {
						q.pos -= 1;
						break _hx_loop3;
					}
					break;
				case 47:
					switch(q.peek()) {
					case 42:
						q.pos++;
						q.skipUntilStr("*/");
						break;
					case 47:
						q.skipUntil(10);
						break;
					}
					break;
				case 59:
					if(depth == 0) {
						q.pos -= 1;
						break _hx_loop3;
					}
					break;
				case 40:case 123:
					++depth;
					break;
				case 41:case 125:
					--depth;
					break;
				}
			}
		}
		q.skipSpaces();
		switch(q.peek()) {
		case 44:
			q.pos += 1;
			break;
		case 59:
			q.pos += 1;
			break _hx_loop1;
		}
	}
};
CppStruct.read = function(q) {
	q.skipSpaces();
	var structName = q.readIdent();
	var struct = new CppStruct(structName);
	var v = struct.proc;
	CppTypeHelper.map.h[structName] = v;
	CppStruct.map.h[structName] = struct;
	q.skipSpaces();
	if(q.skipIfEqu(58)) {
		q.skipSpaces();
		struct.parent = q.readIdent();
	}
	var depth = 0;
	_hx_loop1: while(q.pos < q.len) {
		var c = q.read();
		switch(c) {
		case 34:case 39:
			q.skipCString(c);
			break;
		case 47:
			switch(q.peek()) {
			case 42:
				q.pos++;
				q.skipUntilStr("*/");
				break;
			case 47:
				q.skipUntil(10);
				break;
			}
			break;
		case 40:case 123:
			++depth;
			break;
		case 41:case 125:
			if(--depth <= 0) {
				break _hx_loop1;
			}
			break;
		default:
			if(CharCode.isIdent0(c) && depth == 1) {
				var w = q.readIdent(true);
				switch(w) {
				case "private":case "public":
					break;
				default:
					if(w != structName) {
						CppStruct.readStructField(q,struct,w);
					}
				}
			}
		}
	}
};
var CppStructField = function(type,name) {
	this.size = [];
	this.type = type;
	this.name = name;
};
CppStructField.__name__ = true;
var CppType = function(name) {
	this.__proc = null;
	this.params = [];
	this.isRef = false;
	this.isPointer = false;
	this.isConst = false;
	this.name = name;
};
CppType.__name__ = true;
CppType.read = function(q,name) {
	q.skipSpaces();
	if(name == null) {
		name = q.readIdent();
	}
	if(name == "") {
		return null;
	}
	var isConst = false;
	_hx_loop1: while(q.pos < q.len) if(name == null) {
		if(q.peekn(2) == "::") {
			var n = 2;
			if(n == null) {
				n = 1;
			}
			q.pos += n;
			name = q.readSpIdent();
		} else {
			break;
		}
	} else {
		switch(name) {
		case "const":
			isConst = true;
			name = q.readSpIdent();
			break;
		case "unsigned":
			name = "unsigned " + q.readSpIdent();
			break;
		default:
			if(q.peekn(2) == "::") {
				var n1 = 2;
				if(n1 == null) {
					n1 = 1;
				}
				q.pos += n1;
				name = q.readSpIdent();
			} else {
				break _hx_loop1;
			}
		}
	}
	if(name == "") {
		return null;
	}
	var cppType = new CppType(name);
	cppType.isConst = isConst;
	q.skipSpaces();
	if(q.peek() == 60) {
		q.pos += 1;
		_hx_loop2: while(q.pos < q.len) {
			cppType.params.push(CppType.read(q));
			q.skipSpaces();
			switch(q.read()) {
			case 44:
				q.skipSpaces();
				break;
			case 62:
				break _hx_loop2;
			}
		}
	}
	q.skipSpaces();
	cppType.isPointer = q.skipIfEqu(42);
	cppType.isRef = q.skipIfEqu(38);
	return cppType;
};
CppType.prototype = {
	get_proc: function() {
		if(this.__proc == null) {
			this.__proc = CppTypeHelper.find(this);
		}
		return this.__proc;
	}
	,toGmlCppType: function() {
		if(this.isPointer) {
			switch(this.name) {
			case "byte":case "char":case "uint8_t":
				return "const " + this.name + "*";
			}
		}
		switch(this.name) {
		case "bool":case "byte":case "char":case "double":case "float":case "int":case "int16_t":case "int32_t":case "int8_t":case "short":case "uint16_t":case "uint32_t":case "uint8_t":case "void":
			return "double";
		default:
			return null;
		}
	}
	,toCppType: function() {
		if(this.__toCppType_cache != null) {
			return this.__toCppType_cache;
		}
		var s_b = "";
		if(this.isConst) {
			s_b += "const ";
		}
		s_b += Std.string(this.name);
		if(this.params.length > 0) {
			s_b += "<";
			var sep = false;
			var _g = 0;
			var _g1 = this.params;
			while(_g < _g1.length) {
				var param = _g1[_g];
				++_g;
				if(sep) {
					s_b += ", ";
				} else {
					sep = true;
				}
				s_b += Std.string(param.toCppType());
			}
			s_b += ">";
		}
		if(this.isPointer) {
			s_b += "*";
		}
		if(this.isRef) {
			s_b += "&";
		}
		this.__toCppType_cache = s_b;
		return this.__toCppType_cache;
	}
};
var proc_CppTypeProc = function() {
};
proc_CppTypeProc.__name__ = true;
proc_CppTypeProc.prototype = {
	gmlRead: function(gml,z) {
		throw haxe_Exception.thrown("todo");
	}
	,gmlWrite: function(gml,z,val) {
		throw haxe_Exception.thrown("todo");
	}
	,cppRead: function(cpp,type) {
		var ts = type.toCppType();
		return "__buf__.read<" + ts + ">()";
	}
	,cppWrite: function(cpp,type,val) {
		var ts = type.toCppType();
		cpp.addFormat("%|__buf__.write<" + ts + ">(" + val + ");");
	}
	,getSize: function() {
		return 8;
	}
};
var proc_CppTypeProcSimple = function(gmlType,size) {
	proc_CppTypeProc.call(this);
	this.gmlType = gmlType;
	this.size = size;
};
proc_CppTypeProcSimple.__name__ = true;
proc_CppTypeProcSimple.__super__ = proc_CppTypeProc;
proc_CppTypeProcSimple.prototype = $extend(proc_CppTypeProc.prototype,{
	gmlRead: function(gml,depth) {
		return "buffer_read(__buf__, " + this.gmlType + ")";
	}
	,gmlWrite: function(gml,depth,val) {
		gml.addFormat("%|buffer_write(__buf__, %s, %s);",this.gmlType,val);
	}
	,getSize: function() {
		return this.size;
	}
});
var CppTypeHelper = function() { };
CppTypeHelper.__name__ = true;
CppTypeHelper.find = function(t) {
	var name = t.toCppType();
	return CppTypeHelper.map.h[name];
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
});
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
var haxe_http_HttpBase = function(url) {
	this.url = url;
	this.headers = [];
	this.params = [];
	this.emptyOnData = $bind(this,this.onData);
};
haxe_http_HttpBase.__name__ = true;
haxe_http_HttpBase.prototype = {
	onData: function(data) {
	}
	,onBytes: function(data) {
	}
	,onError: function(msg) {
	}
	,onStatus: function(status) {
	}
	,hasOnData: function() {
		return !Reflect.compareMethods($bind(this,this.onData),this.emptyOnData);
	}
	,success: function(data) {
		this.responseBytes = data;
		this.responseAsString = null;
		if(this.hasOnData()) {
			this.onData(this.get_responseData());
		}
		this.onBytes(this.responseBytes);
	}
	,get_responseData: function() {
		if(this.responseAsString == null && this.responseBytes != null) {
			this.responseAsString = this.responseBytes.getString(0,this.responseBytes.length,haxe_io_Encoding.UTF8);
		}
		return this.responseAsString;
	}
};
var haxe_http_HttpJs = function(url) {
	this.async = true;
	this.withCredentials = false;
	haxe_http_HttpBase.call(this,url);
};
haxe_http_HttpJs.__name__ = true;
haxe_http_HttpJs.__super__ = haxe_http_HttpBase;
haxe_http_HttpJs.prototype = $extend(haxe_http_HttpBase.prototype,{
	request: function(post) {
		var _gthis = this;
		this.responseAsString = null;
		this.responseBytes = null;
		var r = this.req = js_Browser.createXMLHttpRequest();
		var onreadystatechange = function(_) {
			if(r.readyState != 4) {
				return;
			}
			var s;
			try {
				s = r.status;
			} catch( _g ) {
				s = null;
			}
			if(s == 0 && js_Browser.get_supported() && $global.location != null) {
				var protocol = $global.location.protocol.toLowerCase();
				var rlocalProtocol = new EReg("^(?:about|app|app-storage|.+-extension|file|res|widget):$","");
				var isLocal = rlocalProtocol.match(protocol);
				if(isLocal) {
					s = r.response != null ? 200 : 404;
				}
			}
			if(s == undefined) {
				s = null;
			}
			if(s != null) {
				_gthis.onStatus(s);
			}
			if(s != null && s >= 200 && s < 400) {
				_gthis.req = null;
				_gthis.success(haxe_io_Bytes.ofData(r.response));
			} else if(s == null || s == 0 && r.response == null) {
				_gthis.req = null;
				_gthis.onError("Failed to connect or resolve host");
			} else if(s == null) {
				_gthis.req = null;
				var onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
				_gthis.responseBytes = onreadystatechange;
				_gthis.onError("Http Error #" + r.status);
			} else {
				switch(s) {
				case 12007:
					_gthis.req = null;
					_gthis.onError("Unknown host");
					break;
				case 12029:
					_gthis.req = null;
					_gthis.onError("Failed to connect to host");
					break;
				default:
					_gthis.req = null;
					var onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
					_gthis.responseBytes = onreadystatechange;
					_gthis.onError("Http Error #" + r.status);
				}
			}
		};
		if(this.async) {
			r.onreadystatechange = onreadystatechange;
		}
		var uri;
		var _g = this.postData;
		var _g1 = this.postBytes;
		if(_g == null) {
			if(_g1 == null) {
				uri = null;
			} else {
				var bytes = _g1;
				uri = new Blob([bytes.b.bufferValue]);
			}
		} else if(_g1 == null) {
			var str = _g;
			uri = str;
		} else {
			uri = null;
		}
		if(uri != null) {
			post = true;
		} else {
			var _g = 0;
			var _g1 = this.params;
			while(_g < _g1.length) {
				var p = _g1[_g];
				++_g;
				if(uri == null) {
					uri = "";
				} else {
					uri = (uri == null ? "null" : Std.string(uri)) + "&";
				}
				var s = p.name;
				var value = (uri == null ? "null" : Std.string(uri)) + encodeURIComponent(s) + "=";
				var s1 = p.value;
				uri = value + encodeURIComponent(s1);
			}
		}
		try {
			if(post) {
				r.open("POST",this.url,this.async);
			} else if(uri != null) {
				var question = this.url.split("?").length <= 1;
				r.open("GET",this.url + (question ? "?" : "&") + (uri == null ? "null" : Std.string(uri)),this.async);
				uri = null;
			} else {
				r.open("GET",this.url,this.async);
			}
			r.responseType = "arraybuffer";
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			this.req = null;
			this.onError(e.toString());
			return;
		}
		r.withCredentials = this.withCredentials;
		if(!Lambda.exists(this.headers,function(h) {
			return h.name == "Content-Type";
		}) && post && this.postData == null) {
			r.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		var _g = 0;
		var _g1 = this.headers;
		while(_g < _g1.length) {
			var h = _g1[_g];
			++_g;
			r.setRequestHeader(h.name,h.value);
		}
		r.send(uri);
		if(!this.async) {
			onreadystatechange(null);
		}
	}
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Browser = function() { };
js_Browser.__name__ = true;
js_Browser.get_supported = function() {
	if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
		return typeof(window.location.protocol) == "string";
	} else {
		return false;
	}
};
js_Browser.createXMLHttpRequest = function() {
	if(typeof XMLHttpRequest != "undefined") {
		return new XMLHttpRequest();
	}
	if(typeof ActiveXObject != "undefined") {
		return new ActiveXObject("Microsoft.XMLHTTP");
	}
	throw haxe_Exception.thrown("Unable to create XMLHttpRequest object.");
};
var proc_CppTypeProcStruct = function(struct) {
	proc_CppTypeProc.call(this);
	this.struct = struct;
};
proc_CppTypeProcStruct.__name__ = true;
proc_CppTypeProcStruct.gmlRead_impl = function(gml,tp,z,size,size_ind) {
	if(size_ind >= size.length) {
		return tp.gmlRead(gml,z + 1);
	}
	var _arr = "_arr_" + z;
	var _ind = "_ind_" + z;
	var _len = size[size_ind];
	gml.addFormat("var %s = array_create(%d);",_arr,_len);
	gml.addFormat("%|for (var %s = 0; %s < %d; %s++) {%+",_ind,_ind,_len,_ind);
	var val = proc_CppTypeProcStruct.gmlRead_impl(gml,tp,z + 1,size,size_ind + 1);
	gml.addFormat("%s[%s] = %s;",_arr,_ind,val);
	gml.addFormat("%-}%|");
	return _arr;
};
proc_CppTypeProcStruct.gmlWrite_impl = function(gml,tp,z,size,size_ind,val) {
	if(size_ind >= size.length) {
		tp.gmlWrite(gml,z + 1,val);
		return;
	}
	var _arr = "_arr_" + z;
	var _ind = "_ind_" + z;
	var _len = size[size_ind];
	gml.addFormat("%|var %s = %s;",_arr,val);
	gml.addFormat("%|for (var %s = 0; %s < %d; %s++) %{",_ind,_ind,_len,_ind);
	proc_CppTypeProcStruct.gmlWrite_impl(gml,tp,z,size,size_ind + 1,"" + _arr + "[" + _ind + "]");
	gml.addFormat("%-}");
};
proc_CppTypeProcStruct.__super__ = proc_CppTypeProc;
proc_CppTypeProcStruct.prototype = $extend(proc_CppTypeProc.prototype,{
	gmlRead: function(gml,z) {
		gml.addFormat("var _struct_%d = /* %s */array_create(%d);%|",z,this.struct.name,this.struct.fields.length);
		var _g_current = 0;
		var _g_array = this.struct.fields;
		while(_g_current < _g_array.length) {
			var _g1_value = _g_array[_g_current];
			var _g1_key = _g_current++;
			var i = _g1_key;
			var fd = _g1_value;
			var tp = CppTypeHelper.find(fd.type);
			var val = proc_CppTypeProcStruct.gmlRead_impl(gml,tp,z + 1,fd.size,0);
			gml.addFormat("_struct_%d[%d/* %s */] = %s;%|",z,i,fd.name,val);
		}
		return "_struct_" + z;
	}
	,gmlWrite: function(gml,z,val) {
		gml.addFormat("%|var _struct_%d = /* %s */%s;",z,this.struct.name,val);
		var _g_current = 0;
		var _g_array = this.struct.fields;
		while(_g_current < _g_array.length) {
			var _g1_value = _g_array[_g_current];
			var _g1_key = _g_current++;
			var i = _g1_key;
			var fd = _g1_value;
			var tp = CppTypeHelper.find(fd.type);
			var val = CppBuf.fmt("_struct_%d[%d/* %s */]",z,i,fd.name);
			proc_CppTypeProcStruct.gmlWrite_impl(gml,tp,z + 1,fd.size,0,val);
		}
	}
	,getSize: function() {
		var size = 0;
		var _g = 0;
		var _g1 = this.struct.fields;
		while(_g < _g1.length) {
			var fd = _g1[_g];
			++_g;
			var fdSize = fd.type.get_proc().getSize();
			var _g2 = 0;
			var _g3 = fd.size;
			while(_g2 < _g3.length) {
				var arrSize = _g3[_g2];
				++_g2;
				fdSize *= arrSize;
			}
			size += fdSize;
		}
		return size;
	}
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
js_Boot.__toStr = ({ }).toString;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
CppBuf.addFormat_map = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.b += Std.string(val);
		},false);
		_g.h["%s"] = value;
	}
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.b += Std.string(val.b);
		},false);
		_g.h["%b"] = value;
	}
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.b += Std.string(val);
		},false);
		_g.h["%d"] = value;
	}
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.addLine(0);
		},true);
		_g.h["%|"] = value;
	}
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.addLine(1);
		},true);
		_g.h["%+"] = value;
	}
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.addLine(-1);
		},true);
		_g.h["%-"] = value;
	}
	{
		var value = new CppBufFormatMeta(function(b,val,i) {
			b.b += "{";
			b.indent++;
		},true);
		_g.h["%{"] = value;
	}
	$r = _g;
	return $r;
}(this));
CppBuf.addFormat_cache = new haxe_ds_StringMap();
CppFunc.list = [];
CppGen.prepareBuffer = "prepare_buf";
CppGen.nameFormat = "$_raw";
CppGen.exportPrefix = "dllx";
CppStruct.map = new haxe_ds_StringMap();
CppTypeHelper.map = (function($this) {
	var $r;
	var bool = new proc_CppTypeProcSimple("buffer_bool",1);
	var s8 = new proc_CppTypeProcSimple("buffer_s8",1);
	var u8 = new proc_CppTypeProcSimple("buffer_u8",1);
	var s16 = new proc_CppTypeProcSimple("buffer_s16",2);
	var u16 = new proc_CppTypeProcSimple("buffer_u16",2);
	var s32 = new proc_CppTypeProcSimple("buffer_s32",4);
	var u32 = new proc_CppTypeProcSimple("buffer_u32",4);
	var s64 = new proc_CppTypeProcSimple("buffer_u64",8);
	var u64 = new proc_CppTypeProcSimple("buffer_u64",8);
	var f32 = new proc_CppTypeProcSimple("buffer_f32",4);
	var f64 = new proc_CppTypeProcSimple("buffer_f64",8);
	var _g = new haxe_ds_StringMap();
	_g.h["bool"] = bool;
	_g.h["char"] = s8;
	_g.h["unsigned char"] = u8;
	_g.h["int8_t"] = s8;
	_g.h["uint8_t"] = u8;
	_g.h["short"] = s16;
	_g.h["unsigned short"] = u16;
	_g.h["int16_t"] = s16;
	_g.h["uint16_t"] = u16;
	_g.h["int"] = s32;
	_g.h["unsigned int"] = u32;
	_g.h["int32_t"] = s32;
	_g.h["uint32_t"] = u32;
	_g.h["long long"] = s64;
	_g.h["int64"] = s64;
	_g.h["int64_t"] = s64;
	_g.h["uint64_t"] = u64;
	_g.h["float"] = f32;
	_g.h["double"] = f64;
	$r = _g;
	return $r;
}(this));
CppGen.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=script.js.map